/**
 * 手写操作系统
 *
 * 文件名: start.S
 * 功  能: 系统初始引导程序, 计算机启动后由BIOS加载并运行, 该程序的boot存储于磁盘的第1个扇区
 *        在计算机启动时将会由BIOS加载到0x7c00处, 之后将由BIOS跳转至0x7c00处开始运行
 *        随后boot程序完成对二级引导程序loader的加载
 */

#include "boot.h"


/**
 * 计算机启动过程
 * 0. 固定在ROM中的16位实模式程序会跳转到0xFFFF BIOS程序的位置开始执行
 *
 * 1. BIOS Base Input/Output System 基本输入输出系统
 * 计算机启动后先进入BIOS, 此时还是16位实模式
 * 且MMU分页机制, 内存保护模式都被禁止, 只能使用16+4位=20位即1MB内存空间
 * 入口地址固定为0xFFFF, 由固定在ROM中程序拉起
 *
 * BIOS主要工作
 * 1) 对硬件进行自检, 如: 主板, 硬盘, 显卡, 内存等检查, 并保存一些硬件配置数据到固定位置的内存中 boot_info
 * 2) 弹出可选界面或通过引导优先级选择某一设备进行引导, 如: 硬盘, 光盘, 网盘等
 *    然后启动该设备上的引导程序, 这里以硬盘(默认)上的GRUB引导程序为例
 * 3) 这里以磁盘为例, BIOS将磁盘的第1号扇区读取512字节加载到内存0x7C00的位置, 并跳转到该0x7C00位置开始运行
 *    因此只需将GRUB程序存放在第1号扇区就会自动被加载到内存中运行
 * 4) BIOS在加载GRUB引导程序前会做简单的引导标志检查
 *    512字节程序的最后两字节为0x55, 0xAA(引导标志: 0x1FE=0x55, 0x1FF=0xAA)
 * 注意: 硬盘可看作是一个巨大的数组, 其中每个元素是一个扇区, 每个扇区大小为512字节, 数组下标即磁盘扇区的索引
 *
 * 2. GRUB
 * GRUB引导程序, 该程序较小<=512字节, 主要用于为操作系统运行初始化运行环境, 并加载操作系统运行
 *
 * GRUB程序主要工作
 * 1) 硬件检测
 *    检测内存容量
 *    检测磁盘数量等
 * 2) 进入保护模式
 *    从16位实模式进入32位保护模式, 实现4GB内存的访问
 * 3) 加载操作系统
 *    从磁盘加载操作系统image文件, 解析并跳转到操作系统运行
 *
 * Bootloader实现有两种方式
 * 1) boot只负责加载内核, 内核运行环境的初始化工作放在内核的init程序中
 * 2) boot加载loader, 由loader完成内核运行环境的初始化工作, 再将内核加载并运行
 * 本工程采用第二种实现方式
 *
 * 硬件 -> 加载BIOS(0xFFFF)并运行 -> GRUB从磁盘加载到0x7C00并运行
 * -> 硬件检测/实模式->保护模式 -> 从磁盘加载OS到内存中并运行
 */



/**
 * x86在上电后自动进入实模式, 以兼容早期的应用程序
 * 16位代码, 无保护机制, 无MMU分页机制, 只有分段机制, 仅能访问1MB内存空间(16+4位=20位内存空间)
 * 寄存器:
 * 通用寄存器: EAX, EBX, ECX, EDX;  EBP, ESI, EDI, ESP
 * 段寄存器: CS, DS, SS, ES, FS, GS
 *      CS - Code Segment
 *      DS - Data Segment
 *      SS - Stack Segment
 *      ES, FS, GS  Data Segment
 *    实际地址: 16位段值<<4 + offset, 访问范围 0 ~ 1MB空间
 * 状态寄存器: EFLAGS, EIP(Instruction Pointer)
 */



/**
 * BISO程序内存分布图
 *
 * ------------------------------  0xFFFFF
 *     其他BIOS区(0xC0000 ～ 0xFFFFF)
 * ------------------------------  0xC0000
 *     显存(0xA0000 ～ 0xBFFFF)
 * ------------------------------  0xA0000
 *     扩张BIOS数据区(0x80000 ～ 0x9FFFF)
 * ------------------------------  0x80000
 *     自由使用区域(0x500 ～ 0x7FFFF)
 * ------------------------------  0x8000
 *     BIOS程序(512字节, 0x7C00起始地址) 即GRUB引导程序(从磁盘第1号扇区读取)
 * ------------------------------  0x7C00
 *     BIOS栈区
 * ------------------------------  0x500
 *     BIOS数据区(0x400 ～ 0x4FF)
 * ------------------------------  0x400
 *     中断向量表(0x000 ～ 0x3FF)
 * ------------------------------  0x000
 */

// 16位实模式代码务必加上
.code16
.text
.global _start // 声明为全局符号, 其他文件可引用该符号
.extern boot_entry // 引用的外部符号, 在其他文件中有定义

// 以下程序为一级引导boot程序, 它会被BIOS自动从磁盘第1号扇区加载到内存0x7C00处并执行
// 汇编指令语法: mov source, dest
_start:
    // 1. 初始化段寄存器
    mov $0, %ax
    mov %ax, %ds
    mov %ax, %ss
    mov %ax, %es
    mov %ax, %fs
    mov %ax, %gs

    // 2. 设置栈, 使用0x7c00之前的空间作为栈, 大约有30KB的RAM, 足够boot和loader使用
    // https://wiki.osdev.org/Memory_Map_(x86)
    // 将_start首地址(0x7C00)赋给栈顶寄存器esp
    mov $_start, %esp // 等效于 mov $0x7c00, %esp

    /**
     * 当触发BIOS软中断时, 会自动从中断向量表中取相应的地址执行, 参数通过寄存器传递
     * 可通过INT 0x10 软中断指令可提供在BIOS中显示字符的功能
     * AH=0x0E, AL=待显示的字符
     */
    // 3. 使用BIOS 0x10中断显示字符, 显示boot加载完成提示符'L'
    // BIOS函数: https://wiki.osdev.org/BIOS#BIOS_functions
    // BIOS0x10中断: https://blog.csdn.net/qq_28256699/article/details/121103977
    // BIOS中断: https://baike.baidu.com/item/BIOS中断调用/22788153?fr=aladdin
    // 0x00000000 - 0x000003FF区域是BIOS的中断向量表(256个)
    // ah: 须设为0xe显示字符, al: 所要显示的字符
    // bl: 前景色, 在图形模式下表示文字颜色, 文字模式下无功能, bh: 页码, 图形模式下须设为0
    mov $0xe, %ah
    mov $'L', %al
    int $0x10

    /**
     * 第1扇区, 存放BIOS的boot程序
     * 第2扇区开始n个扇区, 存放loader程序, 这里n为65
     * 将第2扇区开始的64个扇区内容, 通过磁盘命令加载到内存0x8000位置
     *
     下面是磁盘操作的参数信息:
     * INT 0x13 软中断指令可提供磁盘读写的功能
     * AH=0x02, AL=扇区数, 填写实际扇区数
     * CH=柱面(=0), CL=扇区号, 这里填写2(扇区数从1开始计数)
     * DH=磁头=0, DL=驱动器类型, 0x00-0x7F 软盘; 0x80-0xFF: 硬盘, 这里填写0x80硬盘
     * ES:BX=缓冲区的地址
     * 出口参数: CF=0 操作成功, AH=0x00, AL=传输的扇区数, 否则AH=状态码
     */
    // 4. 加载loader, 只支持磁盘1, 从磁盘第2号扇区中读取loader程序到内存的0x8000处并运行
    // https://wiki.osdev.org/Disk_access_using_the_BIOS_(INT_13h)
read_loader:
    // 使用BIOS中断读取磁盘
    // boot程序在磁盘的1号扇区, 加载到内存中的0x7c00位置(由BIOS自动完成), 大小为512字节
    // loader程序在磁盘的2-65号扇区, 由boot程序加载到内存中0x8000位置, 大小为64*512=32KB
    mov $0x8000, %bx    // 读取到的内存地址0x8000
    mov $0x2, %ah       // ah: 0x2 读磁盘命令
    mov $0x2, %cx       // ch: 磁道号=0, cl起始扇区号=2
    mov $64, %al        // al: 读取的扇区数量, 必须小于128, 暂设置成64即大小为32KB
    mov $0x0080, %dx    // dh: 磁头号=0, dl驱动器号0x80(磁盘1)
    int $0x13
    jc read_loader      // CF=0 操作成功, 为1时反复读磁盘

    // 跳转至c部分执行, 再由c部分做一些处理
    // jmp跳转后不会再返回. 而call指令是函数调用, 执行完后会跳转回来并执行下一条指令
    jmp boot_entry

    // 原地跳转, 正常情况下不会运行到这
    jmp .

// 引导结束段
.section boot_end, "ax"
// boot程序最后2个字节固定的魔数0x55aa
boot_sig: .byte 0x55, 0xaa

